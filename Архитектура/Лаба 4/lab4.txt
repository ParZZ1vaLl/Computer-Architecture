Завдання:

1. Написати процедуру, що створює декілька масивів arr_stack розміром 
16х16, тип даних слово у сегменті даних. Кількість масивів відповідає 
номеру варіанту. Заповнити масив псевдо-випадковими числами, 
використовуючи способи організації циклів. 
2. Розрахувати розмір стеку для розміщення масиву. Користуючись 
механізмом стеку перенести значення масиву до стеку.
3. Заповнити у стеку рядок масиву числами дня, місяця, року народження 
студентів робочої групи. Номер рядку має відповідати номеру варіанту. 
Скористатися базової адресацією. Визначити фізичну, логічну адреси 
крайніх елементів рядка з числами народження. 
4. Засобами DOS або BIOS зарезервувати пам'ять у розмірі 2 параграфів, 
визначити і зафіксувати початок нового сегменту, розмір памяті що 
виділена. Записати до нової ділянки памяті масив, що отриманий у п.2 
завдання. Переконатися що він є у новій ділянці, зафіксувати результат. 
Звільнити зарезервовану пам'ять.

Описання коду:

IDEAL - це режим який покращує синтаксис мови і розширує його функціональні можливості. Джерело: http://citforum.ru/programming/tasm3/tasm3_3.shtml
MODEL дозволяє нам задати для програми кілька стандартних моделей сегментації. Ми можемо також використовувати її для задання мови для процедур програми. 
Джерело: http://citforum.ru/programming/tasm3/tasm3_7.shtml
STACK визначає стек певного розміру

Далі ми ініціалізуємо макрос я кий називається M_Init
Макрос - це послідовність інструкцій з ім'ям, яка може використовуватися в будь-якому місці програми
В нашому макросі іде ініціалізація регістрів DS та ES а також створення @data - це ідентифікатор, що створюються директивою model

	Регістр DS, сегмента даних, містить початкову адресу сегменту даних, у
	нашому прикладі вимагає ініціалізації і дає можливість адресувати будь яку
	змінну, об’єкт або символьний рядок, що знаходиться у сегменті даних.

	Регістр ES, додатковий регістр, може містити тимчасові значення адрес у
	різних способах адресації, потребує ініціалізації. До регістра покажчика ІР у
	звичайному режимі роботи у розробника немає доступу до цього регістру. 

 
DATASEG - початок сегменту даних
Створюємо двомірний масив array2Db розміром 16х16
exCode - код завершення програми

CODESEG - початок сегменту коду
Спочатку викликаємо наш макрос.

mov cx, 256
        wwww:
            mov bx, [ds:si]             ; get number from array_array stack & set it to bx as a temp variable
            push bx      ; set value from bx to ds with offset 
            add si, 2                    ; si value + 2
            loop wwww
			
    PROC copy_arr       
        xor si, si                       ; set si to zero
		mov cx, 1024
        array_coping_loop:
            mov bx, [ds:si]             ; get number from array_array stack & set it to bx as a temp variable
            mov [ds:[si+100h]], bx       ; set value from bx to ds with offset 
            add si, 2                    ; si value + 2
            loop array_coping_loop
    ENDP
    
Далі замінюємо деякі числа на наші ініціали

	mov [ss:1EB8h], 0320h
	mov [ss:1EB6h], 1027h
	mov [ss:1EB4h], 0220h
	mov [ss:1EB2h], 1112h
	mov [ss:1EB0h], 9219h
	mov [ss:1EAEh], 1114h

І вихід з програми:
 
	mov ah,4ch; Завантаження числа 4ch до регістру ah
	mov al,[exCode]	; отримання коду виходу(тобто 0)
	int 21h	
