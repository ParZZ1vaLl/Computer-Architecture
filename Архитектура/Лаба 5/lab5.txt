Завдання:

1. Користуючись результатами роботи 1, 2, заповнити внутрі массиву 
array2Db ділянку розміром 8х8 числами дня, місяця, року 
народження студенту, що є елементами масиву. 
2. Кординати початку ділянки (i, j) верхнього лівого кута мають 
відповідати варіанту. 
3. Створити процедуру Асемблера, що робить сортування масиву для 
парного варіанту за зростанням, для непарного варіанту за 
зменьшенням. arr_dup2D 

Описання коду:

IDEAL - це режим який покращує синтаксис мови і розширує його функціональні можливості. Джерело: http://citforum.ru/programming/tasm3/tasm3_3.shtml
MODEL дозволяє нам задати для програми кілька стандартних моделей сегментації. Ми можемо також використовувати її для задання мови для процедур програми. 
Джерело: http://citforum.ru/programming/tasm3/tasm3_7.shtml
STACK визначає стек певного розміру

Далі ми ініціалізуємо макрос я кий називається M_Init
Макрос - це послідовність інструкцій з ім'ям, яка може використовуватися в будь-якому місці програми
В нашому макросі іде ініціалізація регістрів DS та ES а також створення @data - це ідентифікатор, що створюються директивою model

	Регістр DS, сегмента даних, містить початкову адресу сегменту даних, у
	нашому прикладі вимагає ініціалізації і дає можливість адресувати будь яку
	змінну, об’єкт або символьний рядок, що знаходиться у сегменті даних.

	Регістр ES, додатковий регістр, може містити тимчасові значення адрес у
	різних способах адресації, потребує ініціалізації. До регістра покажчика ІР у
	звичайному режимі роботи у розробника немає доступу до цього регістру. 

 
DATASEG - початок сегменту даних
Створюємо двомірний масив array2Db розміром 16х16
exCode - код завершення програми

CODESEG - початок сегменту коду
Спочатку викликаємо наш макрос.

push -- загрузить в стек
pop --  вынуть со стека
DEC 	Команда DEC - декрементировать
Описание: Вычитание единицы - 1 - из содержимого регистра Rd и размещение результата в регистре назначения Rd. 

SHL SHR 	SHL и SHR сдвигают биты операнда (регистр/память) влево или вправо соответственно на один разряд. 
Указанное выше действие повторяется количество раз, равное значению второго операнда. 
Это означает: сдвиг всех битов регистра al на 3 разряда вправо. ... Биты слева заполняются нулями, а биты справа выдвигаются.

CMP 	Команда CMP процессоров семейства i80x86 используется для сравнения двух операндов. 
Говоря проще, эта команда сравнивает два числа, то есть проверяет, равны эти два числа или НЕ равны.
Сравнение чисел в Ассемблере с помощью инструкции CMP выполняется по следующему алгоритму:
Из ЧИСЛА1 вычитается ЧИСЛО2 (ЧИСЛО1 - ЧИСЛО2)
Если результат равен нулю, то ЧИСЛО1 = ЧИСЛО2
Если числа равны, то есть результат равен 0, то устанавливается флаг ZF

JBE 	Команда JBE (ПРОСТО ПЕРЕХОД НА МЕТКУ). выполняет короткий переход, если первый операнд МЕНЬШЕ или РАВЕН второму операнду 
при выполнении операции сравнения с помощью команды CMP.
XCHG 	Команда XCHG в Ассемблере выполняет перестановку операндов (то есть меняет местами значения операндов).

sub 	sub -- віднімання

add 	-- додавання

idiv 	--ділення

imul -- множення

xor dx, dx 	-- стирання всего что есть в каком то регистре. 

JA	прыжок когда выполняется условие: (X > Y)


І вихід з програми:
 
	mov ah,4ch; Завантаження числа 4ch до регістру ah
	mov al,[exCode]	; отримання коду виходу(тобто 0)
	int 21h	