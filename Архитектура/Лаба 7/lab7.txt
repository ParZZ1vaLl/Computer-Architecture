Завдання:

Програма під час початку роботи виводить повідомлення.
В залежності від обраного повідомлення вона:
	1. Викликає функцію для видачі звуку.
	2. Викликає функцію для обчислення результату виразу 
	3. Забезпечує вихід з програми
Під час реалізації функцій 
Програма читає зі стандартного вводу (клавіатури) строку.

Описання коду:

IDEAL - це режим який покращує синтаксис мови і розширує його функціональні можливості. Джерело: http://citforum.ru/programming/tasm3/tasm3_3.shtml
MODEL дозволяє нам задати для програми кілька стандартних моделей сегментації. Ми можемо також використовувати її для задання мови для процедур програми. 
Джерело: http://citforum.ru/programming/tasm3/tasm3_7.shtml
STACK визначає стек певного розміру

Далі ми ініціалізуємо макрос я кий називається M_Init
Макрос - це послідовність інструкцій з ім'ям, яка може використовуватися в будь-якому місці програми
В нашому макросі іде ініціалізація регістрів DS та ES а також створення @data - це ідентифікатор, що створюються директивою model

	Регістр DS, сегмента даних, містить початкову адресу сегменту даних, у
	нашому прикладі вимагає ініціалізації і дає можливість адресувати будь яку
	змінну, об’єкт або символьний рядок, що знаходиться у сегменті даних.

	Регістр ES, додатковий регістр, може містити тимчасові значення адрес у
	різних способах адресації, потребує ініціалізації. До регістра покажчика ІР у
	звичайному режимі роботи у розробника немає доступу до цього регістру. 

DATASEG - початок сегменту даних
Створюємо двомірний масив array2Db розміром 16х16
exCode - код завершення програми

CODESEG - початок сегменту коду
Спочатку викликаємо наш макрос.



Додаткові питання:

push -- загрузить в стек
pop --  вынуть со стека

LEA 	Команда LEA в Ассемблере вычисляет эффективный адрес ИСТОЧНИКА и помещает его в ПРИЁМНИК. Синтаксис:

DEC 	Команда DEC - декрементировать
Описание: Вычитание единицы - 1 - из содержимого регистра Rd и размещение результата в регистре назначения Rd. 

SHL SHR 	SHL и SHR сдвигают биты операнда (регистр/память) влево или вправо соответственно на один разряд. 
Указанное выше действие повторяется количество раз, равное значению второго операнда. 
Это означает: сдвиг всех битов регистра al на 3 разряда вправо. ... Биты слева заполняются нулями, а биты справа выдвигаются.

CMP 	Команда CMP процессоров семейства i80x86 используется для сравнения двух операндов. 
Говоря проще, эта команда сравнивает два числа, то есть проверяет, равны эти два числа или НЕ равны.
Сравнение чисел в Ассемблере с помощью инструкции CMP выполняется по следующему алгоритму:
Из ЧИСЛА1 вычитается ЧИСЛО2 (ЧИСЛО1 - ЧИСЛО2)
Если результат равен нулю, то ЧИСЛО1 = ЧИСЛО2
Если числа равны, то есть результат равен 0, то устанавливается флаг ZF

JBE 	Команда JBE (ПРОСТО ПЕРЕХОД НА МЕТКУ). выполняет короткий переход, если первый операнд МЕНЬШЕ или РАВЕН второму операнду 
при выполнении операции сравнения с помощью команды CMP.

XCHG 	Команда XCHG в Ассемблере выполняет перестановку операндов (то есть меняет местами значения операндов).

sub 	sub -- віднімання

add 	-- додавання

idiv 	--ділення

imul -- множення

xor dx, dx 	-- стирання всего что есть в каком то регистре. 

JA	прыжок когда выполняется условие: (X > Y)

JE 	Инструкция JE выполняет короткий переход, если первый операнд РАВЕН второму операнду при выполнении операции сравнения
 с помощью команды CMP. То есть вверху сравниваем, а строкой ниже JE -- прыжок на метку.

jmp 	jmp просто прыжок при любых условиях. 

JNE	Переход, если не равно. Проверяется бит нуля (Z) регистра статуса. Если бит Z установлен, выполняется команда, следующая за инструкцией jump.


JZ	прыжок если (X = Y). В нашем случае:
 cmp [simvol],'e' ; Перевірка на відповідність і встановлення прапору ознаки 0
 jz Exit ;  ---------------------если символ с консоли равный е -- прыжок на метку.

IN и OUT	 Команды IN и OUT используются для работы с внешними устройствами через порты ввода-вывода. 
IN принимает данные из порта, а команда OUT записывает данные в порт. 

OR 	(кдм нужно вспомнить) Инструкция OR выполняет побитовую операцию ИЛИ. Побитовый оператор ИЛИ возвращает 1, если совпадающие биты одного или
 обоих операндов равны 1, и возвращает 0, если оба бита равны нулю. 

TEST 	Команда TEST выполняет логическое И между всеми битами двух операндов. 
Результат никуда не записывается, команда влияет только на флаги (то есть первый операнд не изменяется).
В зависимости от результата могут быть изменены флаги ZF, SF, PF. Инструкция TEST всегда сбрасывает флаги OF и CF.

JNZ 	Переход по в зависимости от флага ZF (ZF должеть быть = 0)

STOSb 	Сохранить AL по адресу ES:DI

MOVZX op1,op2 Копирует данные из op2 в op1 с расширением нулем.

POPA  вынуть из стека регистры DI, SI, BP, BX, DX, CX и AX

PUSHA Сохранить в стеке регистры AX, CX, DX, BX, исходный SP, BP, SI и DI

JAE  Перейти, если значение выше в коде больше или равно